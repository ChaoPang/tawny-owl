

* Move the reasoner code into ontology options



* Remove the Ontology Record and use java object

The existance of an Ontology record with an ontology inside it 
is a pain in the ass for many reasons -- mostly because I have to remember the
layer of indirection. So I want to get away from this and just use the
underlying Java object

** Get prefix from ontology

(.isPrefixOWLOntologyFormat
 (.getOntologyFormat owl-ontology-manager (#'get-current-jontology)))

returns true -- so by default, we should be able to get the format. Then

public java.util.Map<java.lang.String,java.lang.String> getPrefixName2PrefixMap()

Description copied from interface: PrefixManager
Gets a map that maps prefix names to prefixes.

should let us get the prefix name (that is owl:) for prefix (that is url). The
map is backward, but such is life. 

Setting prefix is easy -- save-ontology has the code. 

** IRI

Easy to get -- from the ontology ID object which comes direct from the
Ontology object.

** Options 

Just put these damn options in! Ah well. 

Currently only used by memorise to store remembered entities. This can be 
replaced by a map, with appropriate hooks. Currently, I have this for
reasoner. This should be easy to generalise -- map from ontology to another
map. Second map can use namespaced keywords, and we can put anything we want
into it. 

Perhaps, can use this for lookup cache also. 

Maybe, a better idea here is to use the IMeta interface and extends-type
support to add metadata to ontologies. This doesn't work for the reasoner
however, as I need to be able to blitz all the reasoners when the factory
changes (which doesn't affect ontologies). 

Lookup cache is namespace based. I guess I could add this to the namespace
metadata? Although, why not the ontology? Can get the ontology from the
namespace after all. 


So, final decision. Will create a (options ontology) method in owl.clj, which
returns a hash for each and an (update-options f ontology) which applies
function f which updates. We store this in a ref. Then we hook into ontology
creation/destruction code, so that we can clear things up appropriately.

This means that ontologies have to be removed explicitly; but then they do
anyway because the ontology manager holds onto them. So only a problem if
ontologies are created with random IRIs. 

Reasoner can also be updated. This will make the task of getting all reasoners
a little harder -- we iterate through all options, get the reasoner, kill it.
But, we can do this one after the other. 


* Annotation Problems

 - [] create new add-a-annotation method which adds a single annotation.
 - [] Change add-annotation to use it.
 - [] Change add-a-annotation to multimethod keyed on class of first entity.
 - [] Add OWLNamedEntity should pass directly, rather than conversion of IRI.
 - [] Add support for OWLOntology -- need different AddOntologyAnnotation
      which we will only use in this place. 
      


* IRI Creation

Have a OBO style generator. 

Initially, generate an UUID style identifer for new terms. Can use memorise to
save and to store these in a file. Add a URI gen client which will search for
these, and replace them with newly minted URIs. Have to add a purl creation
client also, which will update all purls and make sure that they point to the
correct place. 


* Enhancements

** Clojure IDs as annotation

The identifiers used within clojure should be placed onto the ontology as
annotations. The idea here is that someone using clojure-owl to generate an
OWL file, should be able to read this OWL file in and recreate what they
started with (at least in terms of ids and so on). 


** Version ID

Support Version ID for everything.



** tawny.lookup optimisation

This is potentially very slow. Add a cache to hold the map. 
Put hooks into tawny.old macros for "new var creation". When this 
pings, just kill the cache and start again. 

Also, kill on ontology kill I think. 


** add :ontology frame to all things

We should be able to specify the ontology as a parameter, to 
all things that add to an ontology -- with-ontology is a bit unwieldy. 
Although we might want to use with-ontology to implement this, or I will have
to pass it around a lot. 

A new frame would be one option. Or the first parameter would be another. 

** Autoname

An autoname facility might be nice for where I can't be assed to specify a
name. Especially good for probe classes. Easiest way is to just implement a
new owlclass function. 




* Bugs 

** transitive 

and other facets are all stored as strings which is dangerous.

Fixed, this by turning them into objects, but this fails also, for reasons I
don't quite understand yet. 


** Ontology reload

Now we have tawny.lookup, it *should* be possible to unmap all vars in a
namespace when an ontology is re-evaled. Just do "tawny.lookup", then ns-umap
the entire lot. 


** Polyglot crashes with no resource

When loading polyglot crashes with this error. This happens when we can't find
the pizzalabel file (or whatever). This happens when we are jacked into the
wrong project and load pizza.clj manually. 

Not sure what the right fix is. A nicer crash at minimum.

java.lang.IllegalArgumentException: No implementation of method: :make-reader of protocol: #'clojure.java.io/IOFactory found for class: nil
 at clojure.core$_cache_protocol_fn.invoke (core_deftype.clj:527)
    clojure.java.io$fn__8239$G__8234__8246.invoke (io.clj:73)
    clojure.java.io$reader.doInvoke (io.clj:106)
    clojure.lang.RestFn.invoke (RestFn.java:410)
    tawny.polyglot$polyglot_load_label.invoke (polyglot.clj:48)
    user$eval2705.invoke (NO_SOURCE_FILE:1)
